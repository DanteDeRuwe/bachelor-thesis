\section{The evolution from monolithic to distributed architectures}

The development of applications for the web has seen some dramatic shifts over
the years. Apart from new technologies, protocols, and standards, the way web
applications are structured has undergone some evolutions as well. ``Software
architecture'' not only outlines the pure structure of the application but also
defines the responsibility of all the pieces of the application, and how these
pieces ought to interact with each other \autocite{Fedorov_etal_1998}.


\subsection{Monolithic architecture}

Historically, one of the earliest architectures for implementing web
applications was the \textbf{client-server model}. The service provider or
\textit{server} can share its resources with service users called
\textit{clients}. According to \textcite{Reese_2000}, at the time, most web
applications were simple two-tier client-server applications. The web browser on
the client-side retrieves data and files from the data store at the webserver
side, without much data interpretation or manipulation. The upcoming increase of
the computing power of hardware, made it possible to execute some data
processing on the client-side, using for example technologies like Java. 

Although two-tier server-client architectures were quick to set up and had
robust tooling, a pretty significant downside got introduced: these so-called
\textit{fat clients} were now not only concerned with the task of presenting
data to the user, but are also bloated with business logic and data processing.
Conversely, any change in business rules would also require every client to adapt
to this change. \autocite{Gallaugher_Ramanathan_1996}.

A \textbf{three-tier} architecture was conceptualized in an attempt to overcome
the downsides of the two-tier approach. The idea sounds not very groundbreaking:
just introduce the handling of business logic on the server-side, rather than on
the client. This results in the following tiers \autocite{Aarsten_etal_1996}:

\begin{itemize}
    \item The client tier (also known as the presentation tier), which contains
    the \gls{gui}
    \item The application tier (also known as the business tier or logic tier),
    i.e. the application servers that contain objects representing business
    entities and domain logic.
    \item The data(base) tier that handles the storage of domain objects and data.
\end{itemize}



% two-tier vs three tier figure here? 

With the introduction of this physical seperation, the next challenge was the
structure of the sotware's code.  

Over an extensive period, applications built on top of the client-server model
extensively used the \textbf{\gls{mvc} pattern} \autocite{Pavlenko_etal_2020}. Like the
name suggests, this pattern describes 3 parts, that are used as conceptual and
architectural separations in the software. The business logic of the application
is encapsulated in the \textbf{model}, the presentation logic is the
responsibility of the \textbf{view}, and the \textbf{controllers} handles the
the user actions in the view, and connects these actions to the appropriate
models and updated views.

However, according to \textcite{Leff_Raylfield_2001}, implementation of the
\gls{mvc} pattern for web applications in a client-server environment, brings up
the question of partitioning between servers and clients. Instinctively it is
clear that the views belong to the client and the models belong to the server,
but for the controllers, this separation is not so clear. Assigning the
controllers to the client-side would result in a \textit{fat client} again,
while assigning them to the server-side (the \textit{thin client} approach)
would often mean too many round-trips to the server must be performed on every
request. In practice, the workaround for this partitioning is a \textit{dual
\gls{mvc}} approach, which partitions the controllers between the client and the
server.





\subsection{The split stack development model}