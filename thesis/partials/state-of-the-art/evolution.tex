\section{The evolution from \gls{monolithic} to distributed architectures}

The development of applications for the web has seen some dramatic shifts over
the years. Apart from new technologies, protocols, and standards, the way web
applications are structured has undergone some evolutions as well. ``Software
architecture'' not only outlines the pure structure of the application but also
defines the responsibility of all the pieces of the application, and how these
pieces ought to interact with each other \autocite{Fedorov_etal_1998}.


\subsection{\Gls{Monolithic} architecture}

Historically, one of the earliest architectures for implementing web
applications was the \textbf{client-server model}. The service provider or
\textit{server} can share its resources with service users called
\textit{clients}. According to \textcite{Reese_2000}, at the time, most web
applications were simple two-tier client-server applications. The web browser on
the client-side retrieves data and files from the data store at the webserver
side, without much data interpretation or manipulation. The upcoming increase of
the computing power of hardware, made it possible to execute some data
processing on the client-side, using for example technologies like Java. 

Although two-tier server-client architectures were quick to set up and had
robust tooling, a pretty significant downside got introduced: these so-called
\textit{fat clients} were now not only concerned with the task of presenting
data to the user, but are also bloated with business logic and data processing.
Conversely, any change in business rules would also require every client to adapt
to this change. \autocite{Gallaugher_Ramanathan_1996}.

A \textbf{three-tier} architecture was conceptualized in an attempt to overcome
the downsides of the two-tier approach. The idea sounds not very groundbreaking:
just introduce the handling of business logic on the server-side, rather than on
the client. This results in the following tiers \autocite{Aarsten_etal_1996}:

\begin{itemize}
    \item The client tier (also known as the presentation tier), which contains
    the \gls{gui}
    \item The application tier (also known as the business tier or logic tier),
    i.e. the application servers that contain objects representing business
    entities and domain logic.
    \item The data(base) tier that handles the storage of domain objects and data.
\end{itemize}



% two-tier vs three tier figure here? 

With the introduction of this physical seperation, the next challenge was the
structure of the sotware's code.  

Over an extensive period, applications built on top of the client-server model
extensively used the \textbf{\gls{mvc} pattern} \autocite{Pavlenko_etal_2020}. Like the
name suggests, this pattern describes 3 parts, that are used as conceptual and
architectural separations in the software. The business logic of the application
is encapsulated in the \textbf{model}, the presentation logic is the
responsibility of the \textbf{view}, and the \textbf{controllers} handles the
the user actions in the view, and connects these actions to the appropriate
models and updated views.

However, according to \textcite{Leff_Raylfield_2001}, implementation of the
\gls{mvc} pattern for web applications in a client-server environment, brings up
the question of partitioning between servers and clients. Instinctively it is
clear that the views belong to the client and the models belong to the server,
but for the controllers, this separation is not so clear. Assigning the
controllers to the client-side would result in a \textit{fat client} again,
while assigning them to the server-side (the \textit{thin client} approach)
would often mean too many round-trips to the server must be performed on every
request. In practice, the workaround for this partitioning is a \textit{dual
\gls{mvc}} approach, which partitions the controllers between the client and the
server.


While the \gls{mvc} architecture pattern can give developers a cleaner
seperation of concerns in their code, it still produces a \textbf{tightly
coupled} solution. Any change would still mean the entire code would have to be
rebuilt and redeployed \autocite{Fowler_Microservices_2014}. This significantly
reduces development speed, as well as agility. \Glsplural{monolith} can also be considered
a  ``single point of failure'': whenever one part of the software is
malfunctioning, the whole system is crippled.


\subsection{The split stack development model}


In more recent times, developer teams started to adopt \textbf{split stack
development}, where the \gls{gui} is handled in the so-called ``\gls{frontend}'' and
the business and data logic are dealt with by a ``\gls{backend}'' system. The
communication between these two parts can be carried out in multiple ways, but
one of the most common ways is via a (RESTful) \gls{api}.

%TODO figure

Decoupling the frontend presentation logic from the \gls{backend} business logic
introduces some major benefits: \autocite{Dunkley_2016}
\begin{itemize}
    \item \textbf{Multiple clients}\\
    As it is not at all concerned with presentation logic, the same
    \gls{backend} service can now serve data to multiple different clients (e.g.
    web, desktop, mobile,...). To support a new type of client, only
    presentation logic has to be implemented. 
    %
    \item \textbf{Specialized teams}\\
    The split of \gls{frontend} and \gls{backend} allows developers to
    specialize themselves in these fields, yielding a deeper knowledge of the
    selected fields. 
    %
    \item \textbf{Independent technology stacks}\\
    Tying in with the previous point: as teams specialize, they desire and/or
    require more specialized technologies. The decoupling of front- and
    \gls{backend} removes any restraints on technology selection between the two
    areas. For example, \gls{frontend} developers can use client-side
    technologies and frameworks such as Typescript and React, while
    \gls{backend} developers can leverage server-side technologies such as .NET
    or Java. This also makes each individual solution more future-proof. 
    %
    \item \textbf{Simultaneous development}\\
    As a result of all outlined benefits above, and the basic concept of
    decoupling, teams can work independently, autonomously and therefore
    simultaneously. For example, a change to the visual styling of a website,
    will not require any of the server-side code to change, and will also not
    trigger a rebuild there.
    %
    \item \textbf{Independent deployment and scaling}\\
    While a \gls{monolith} had to be deployed as one big program, teams could now
    deploy the \gls{frontend} and \gls{backend} solutions according to their
    needs. Often a static hosting solution is enough to publish a client, while
    a \gls{backend} service might need some serious infrastructure to remain
    operational.
\end{itemize}

% TODO callback to distributed development?

Of course, these benefits also come at the cost of some drawbacks. 

Firstly, the contract between the \gls{frontend} and \gls{backend} teams is a
well documented \gls{api} with clearly defined \glsplural{endpoint}. For RESTful
web \gls{api} \textbf{documentation}, the OpenAPI
specification\hreffootnote{https://www.openapis.org/}, which is also known as
\textit{Swagger} documentation, provides a standardized way of defining this
contract \autocite{Koren_Klamma_2018}. Of course, time and effort needs to be
spent creating robust documentation. 

Secondly, breaking changes have to be avoided at all times. \Gls{frontend} code
might depend on backend \glsplural{endpoint} that will get deleted in an
upcoming update. This is not acceptable.
\textbf{Versioning}\hreffootnote{https://restfulapi.net/versioning/} provides a
way to keep supporting clients that rely on a version of the \gls{api} before
the breaking change was made.

Lastly, more relevant in the context of this thesis: while dividing the
\gls{frontend} from the \gls{backend} does provide benefits; in large, rapidly
scaling applications, it simply isn't enough. After a
\gls{frontend}-\gls{backend} split, one does still end up with a both a
\textbf{\gls{monolithic} \gls{backend}} and a \textbf{\gls{monolithic}
\gls{frontend}}. 

Shifting the frame of reference to the server-side: the \gls{backend}
\gls{monolith} still posesses the same downsides the overall \gls{monolith} had
introduced: one change in the logic and the entire application has to be
rebuilt and redeployed. Also, the issue of scaling still persists: the server
can be updated with more powerful hardware (vertical scaling) or the \textit{entire}
server-sice application can be replicated on different servers, with a
\gls{load-balancer} deciding how to distribute incoming requests (horizontal scaling).
Keyword here is \textit{``entire''}, as no specific part of the server-side
application can be scaled up indendently. 

