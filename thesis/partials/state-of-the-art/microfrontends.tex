\section{Microfrontends}

With the introduction of the \gls{ma} pattern, \gls{backend} systems can be
split up into multiple services, each with their own responsibilities. As
previously described, this can bring great benefit. However, even after a
transition to \glsplural{microservice} on the server-side, the client-side
applications using these services are mostly still \gls{monolithic} in nature.

A \gls{monolithic} \gls{frontend} does not have to be a problem.
\Glsplural{monolith} are quick and easy to set up, and historically, most of the
heavy lifting was done on the server-side anyway. However, the complexity of
client-side applications has seen a drastic increase over the last few years.
This can be attributed to many factors: increased hardware and web browser
capabilities, a broad variety of client devices, a massive market growth for
digital services, and the web transitioning from a document platform to the
largest application platform \autocite{Ball_2019}, just to name a few.

In these complex applications, the downsides of a \gls{monolithic} architecture
come back into view: every change requires the entire \gls{frontend} application
to be rebuilt and redeployed, codebases grow very large in size, etc... Even
worse, because the client-side application has a functional dependency on the
server-side application, a small change in one particular area of the
\gls{backend} logic could also trigger a change in the \gls{frontend}, causing
the entire \gls{frontend} to yet again be rebuilt and redeployed
\autocite{Rappl_LogRocket_2019}.

There's also the issue of \textbf{domain knowledge}: while the \gls{ma} gives
\gls{backend} teams the possibility of focussing on one specific part of a
business domain, teams that are developing the client-side code are still
expected to know the entire scope of the application. Often this means a
reliance on personal inter-team communication, which in larger organizations
tends to be expensive \autocite{Geers_2020}. 

While component-based paradigms introduced by libraries and frameworks (such as
React\hreffootnote{https://reactjs.org},
Angular\hreffootnote{https://angular.io} and
Vue\hreffootnote{https://vuejs.org}) can aliviate some of the complexity of the
current frontend systems, they still do not enable  fully autonomous, decoupled,
modular and/or distributed development of large web applications.

\subsection{What are microfrontends?}

In 2016 the ThoughtWorks Technology Radar \autocite{ThoughtWorks_2020} coined
the term ``\textit{Micro Frontends}'' to describe the split of the
\gls{frontend} \gls{monolith} into independently deployable and maintainable
pieces. This new architecture pattern could therefore be regarded as an
extension of the \gls{ma} into the \gls{frontend} space.

The characteristics of the \gls{mfa} pattern are therefore very closely related
to those of the \gls{ma} pattern, as described in section
\fullref{principles-of-the-mfa}. Every individual \gls{frontend} module has a
relatively small codebase, is focussed around one specific domain or company
mission, and should be modular, decoupled and independently developed; most
optimally by autonomous teams.

\subsection{How do microfrontends enable distributed development?}

A significant difference between \glsplural{microfrontend} and other software
architectures is the impact on \textbf{team structure} and organizational shift
\autocite{Geers_2020}.

So, while \glsplural{microfrontend} have lots of technical aspects to consider,
it is important to reflect on the organizational aspects first.

As disussed in \fullref{ssec:microservices}, when adopting the \gls{ma}, a shift
has to be made to smaller independent teams around a specific business need.
However, this only brings about changes in the \gls{backend} teams, while the
\gls{frontend}-oriented development team will usually not follow suit. This
keeps the overarching team structure ``horizontal'': divided per layer or
technology.

One of the benefits of horizontal teams is that this structure enables experts
focussing on specific technologies to co-operate together as one team. This way
they can ensure a high technical standard within the boundaries of their
respective areas of expertise.

In geographically distributed teams, the consequence could be that these
technical teams operate from entirely different locations. According to
\textcite{Smite_etal_2010}, this can result in compatibility issues between software
layers and a less customer-focused development model. Moreover, disputes can
arise between the different teams because no team has full responsibility over
the delivery of any feature.

\subsubsection{feature teams}
\label{feature-teams}

%TODO add images?

To mitigate the issues arising from geographically distributed horizontal teams;
multidisciplinary or cross-functional ``feature teams'' can be introduced. These
are grouped around a specific business case or customer need. This ``vertical
slicing''  enables teams to be more independent and have end-to-end
responsibility for the features they develop.

This feature team approach has multiple advantages: \autocite{Smite_etal_2010}
\begin{itemize} 
  \item \textbf{Optimized feature development}\\
  Focussing on features in stead of technical details aids in delivering the
  highest amount of business value.
  % 
  \spacedItem \textbf{Decreased need for ``expensive'' communication}\\
  Communications within a team is usually faster and more informal than
  communications between teams, especially if teams are geographically
  distributed. Since a feature can be developed by a single team, the need for
  expensive communication decreases.
  %
  \spacedItem \textbf{Greater sense of developer involvement}\\
  According to \autocite{LarmanVodde_2008}, developers who operate in a feature
  team feel a greater sense of ownership and accountability for the features
  they develop. 
  %
\end{itemize}

It is worth mentioning that these benefits combined can result in a faster cycle
time and thus an increase in development speed \autocite{Geers_2020}.

On the other side, this approach also comes with caveats. One of them is the
danger of compromising on the \textbf{conceptual integrity} of the software
systems. More time will have to be spent up-front laying a solid foundation for
conventions and standards. The effort to then maintain the consistency of the
software system is usually where the software architect has a key role. In
larger projects, a technical service team can be assembled to provide technical
coherence across different distributed systems \autocite{Smite_etal_2010}. WHile
this is something to consider, this also means an increased emphasis on better
code quality right from the start, which could prove very beneficial in the long
term \autocite{LarmanVodde_2008}.

Another caveat is that, especially in large corporations, \textbf{changing the
complicated organizational structure} might not be possible, or at the very
least slow and difficult.

\subsection{Common implementation patterns}

As is the case with lots of architectural patterns, there are many ways of
implementation possible. With the \gls{mfa}, this is no different. Various
options differ in complexity, goal, and mechanism. Below some of the most common
ways of implementation are outlined.

\subsubsection{The \textit{web approach}}

The most straightforward way of leveraging the \gls{mfa} pattern is by not using
any integration technique at all. In stead, there can be opted for mechanisms
that exist in the world of the web. 

As described by \textcite{Rappl_2021}, the \textit{web approach}'s main approach
for \gls{microfrontend} referencence is by way of their \gls{url}.
\textbf{Hyperlinks} can be used to let the user navigate between different
\glsplural{microfrontend}. This however compromises on user experience and
usability. With this approach, for example, elements from multiple
\glsplural{microfrontend} cannot be rendered on the same page. 

To enable visual composition of \glsplural{microfrontend} in the most
straightforward way, \textbf{\glsplural{iframe}} can be used. By using an
\texttt{<iframe>} tag with a \texttt{src} attribute that points to a \gls{url},
one could embed visual components of one \gls{microfrontend} within another,
without sacrificing on strong isolation between the two \autocite{Geers_2020}.
The disadvantage here is the notoriously bad characteristics of
\glsplural{iframe}. One of these is bad performance: according to
\textcite{Souders_2013}, \glsplural{iframe} are up to 2 orders of magnitude more
expensive to create than any other \gls{dom} element. Moreover, iframes also
block the loading process of the rest of the page. Other suboptimal
characteristics include accessibility, \gls{seo}, and security.

The simplicity of the web approach is also where it lacks applicability for
larger projects. One of the biggest reasons to implement
\glsplural{microservice} and \glsplural{microfrontend} is scalibility, which the
web approach is not suitable for.

\subsubsection{Server-side composition}
...
\subsubsection{Client-side composition}
...
\subsubsection{Universal composition}
...

\subsection{Usage of microfrontends}
...

\subsubsection{benefits}

The \gls{mfa} carries over a lot of the advantages of the \gls{ma}
\autocite{Jackson_2019}: \textbf{Technology independence} is now also possible
across different \gls{frontend} teams, allowing them to select the best tools
and frameworks for the job. Loose coupling enables the \textbf{scalibility} of
both the \gls{frontend} and \gls{backend}. Now, the \gls{frontend} can also
enjoy the benefits of independent deploys, isolated risks, and smaller
codebases.

\textbf{Teams} also benefit greatly and can be reorganized to even greater
benefit, as was discussed in section \fullref{feature-teams}.

...
% TODO more

\subsubsection{known drawbacks, limitations and caveats}

However, to use the words of Cam \textcite{Jackson_2019}: \textit{``there are no
free lunches when it comes to software architecture - everything comes with a
cost''}. The \gls{mfa} does indeed come with a significant amount of tradeoffs
that need to be considered. 

...
% TODO more